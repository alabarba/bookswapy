import * as yup from 'yup';
export declare type RequiredKeys<T> = {
    [K in keyof T]-?: string extends K ? never : number extends K ? never : {} extends Pick<T, K> ? never : K;
} extends {
    [_ in keyof T]-?: infer U;
} ? U extends keyof T ? U : never : never;
export declare type OptionalKeys<T> = {
    [K in keyof T]-?: string extends K ? never : number extends K ? never : {} extends Pick<T, K> ? K : never;
} extends {
    [_ in keyof T]-?: infer U;
} ? U extends keyof T ? U : never : never;
export declare type FlatConvectorModel<T> = {
    [L in Exclude<OptionalKeys<T>, keyof ConvectorModel<any>>]?: T[L];
} & {
    [L in Exclude<RequiredKeys<T>, keyof ConvectorModel<any>>]: T[L];
};
export interface History<T> {
    value: T;
    txId: string;
    timestamp: number;
}
export declare abstract class ConvectorModel<T extends ConvectorModel<any>> {
    private static type;
    static schema<T extends ConvectorModel<any>>(this: Function & {
        prototype: T;
    }): yup.ObjectSchema<FlatConvectorModel<T> & {
        id: string;
        type: string;
    }>;
    static getOne<T extends ConvectorModel<any>>(this: new (content: any) => T, id: string, type?: new (content: any) => T, storageOptions?: any): Promise<T>;
    static query<T>(type: new (content: any) => T, ...args: any[]): Promise<T | T[]>;
    static getAll<T extends ConvectorModel<any>>(this: new (content: any) => T, type?: string): Promise<T[]>;
    id: string;
    readonly abstract type: string;
    constructor();
    constructor(id: string);
    constructor(content: {
        [key in keyof T]?: T[key];
    });
    update(content: {
        [key in keyof T]?: T[key];
    }): Promise<void>;
    fetch(storageOptions?: any): Promise<void>;
    history(): Promise<History<T>[]>;
    save(storageOptions?: any): Promise<void>;
    clone(): T;
    toJSON(skipEmpty?: boolean): {
        [key in keyof T]?: T[key];
    };
    delete(storageOptions?: any): Promise<void>;
    private assign(content, defaults?);
}
