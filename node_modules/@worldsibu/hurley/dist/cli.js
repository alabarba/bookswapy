"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var sysWrapper_1 = require("./utils/sysWrapper");
var os_1 = require("os");
var path_1 = require("path");
var analytics_1 = require("./utils/analytics");
var configtx_yaml_1 = require("./generators/configtx.yaml");
var cryptoconfig_yaml_1 = require("./generators/cryptoconfig.yaml");
var cryptofilesgenerator_sh_1 = require("./generators/cryptofilesgenerator.sh");
var dockercompose_yaml_1 = require("./generators/dockercompose.yaml");
var networkRestart_sh_1 = require("./generators/networkRestart.sh");
var networkClean_sh_1 = require("./generators/networkClean.sh");
var logs_1 = require("./utils/logs");
var networkprofile_yaml_1 = require("./generators/networkprofile.yaml");
var downloadFabricBinaries_1 = require("./generators/downloadFabricBinaries");
var chaincodegenerator_1 = require("./generators/chaincodegenerator");
var storage_1 = require("./utils/storage");
var chaincodeinteractor_1 = require("./generators/chaincodeinteractor");
var CLI = (function () {
    function CLI() {
    }
    CLI.createNetwork = function (organizations, users, channels, path, inside, skipDownload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new NetworkCLI();
                        return [4, cli.init(Number.parseInt(organizations), Number.parseInt(users), Number.parseInt(channels), path, inside, skipDownload)];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    CLI.cleanNetwork = function (rmi) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new NetworkCLI();
                        return [4, cli.clean(rmi)];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    CLI.installChaincode = function (chaincode, language, channel, version, params, path, ccPath, colConfig, inside, debug) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new ChaincodeCLI(chaincode);
                        return [4, cli.installChaincode(chaincode, language, channel, version, params, path, ccPath, colConfig, inside, debug)];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    CLI.upgradeChaincode = function (chaincode, language, channel, version, params, path, ccPath, colConfig, inside) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new ChaincodeCLI(chaincode);
                        return [4, cli.upgradeChaincode(chaincode, language, channel, version, params, path, ccPath, colConfig, inside)];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    CLI.invokeChaincode = function (chaincode, fn, channel, path, user, organization, inside, transientData) {
        var args = [];
        for (var _i = 8; _i < arguments.length; _i++) {
            args[_i - 8] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cli;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cli = new ChaincodeCLI(chaincode);
                        return [4, cli.invokeChaincode.apply(cli, [chaincode, fn, channel, path, user, organization, inside, transientData].concat(args))];
                    case 1:
                        _a.sent();
                        return [2, cli];
                }
            });
        });
    };
    return CLI;
}());
exports.CLI = CLI;
var NetworkCLI = (function () {
    function NetworkCLI() {
        this.networkRootPath = './hyperledger-fabric-network';
        this.analytics = new analytics_1.Analytics();
    }
    NetworkCLI.prototype.init = function (organizations, users, channels, path, inside, skipDownload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.analytics.init();
                this.initNetwork(organizations, users, channels, path, inside, skipDownload);
                return [2];
            });
        });
    };
    NetworkCLI.prototype.initNetwork = function (organizations, users, channels, path, insideDocker, skipDownload) {
        if (skipDownload === void 0) { skipDownload = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, orgs, chs, usrs, config, cryptoConfig, dockerComposer, cryptoGenerator, networkRestart, binariesDownload;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        path = path ? path_1.resolve(os_1.homedir(), path) : path_1.join(os_1.homedir(), this.networkRootPath);
                        _a = buildNetworkConfig({ organizations: organizations, channels: channels, users: users }), orgs = _a.orgs, chs = _a.chs, usrs = _a.usrs;
                        config = new configtx_yaml_1.ConfigTxYamlGenerator('configtx.yaml', path, {
                            orgs: orgs,
                            channels: 1
                        });
                        cryptoConfig = new cryptoconfig_yaml_1.CryptoConfigYamlGenerator('crypto-config.yaml', path, {
                            orgs: orgs,
                            users: users
                        });
                        dockerComposer = new dockercompose_yaml_1.DockerComposeYamlGenerator('docker-compose.yaml', path, {
                            orgs: orgs,
                            networkRootPath: path,
                            envVars: {
                                FABRIC_VERSION: '1.4.0',
                                THIRDPARTY_VERSION: '0.4.14'
                            }
                        });
                        cryptoGenerator = new cryptofilesgenerator_sh_1.CryptoGeneratorShGenerator('generator.sh', path, {
                            orgs: orgs,
                            networkRootPath: path,
                            channels: chs,
                            envVars: {
                                FABRIC_VERSION: '1.4.0'
                            }
                        });
                        networkRestart = new networkRestart_sh_1.NetworkRestartShGenerator('restart.sh', path, {
                            organizations: orgs,
                            networkRootPath: path,
                            channels: chs,
                            users: users,
                            insideDocker: insideDocker,
                            envVars: {
                                FABRIC_VERSION: '1.4.0',
                                THIRDPARTY_VERSION: '0.4.14'
                            }
                        });
                        binariesDownload = new downloadFabricBinaries_1.DownloadFabricBinariesGenerator('binaries.sh', path, {
                            networkRootPath: path,
                            envVars: {
                                FABRIC_VERSION: '1.4.0',
                                THIRDPARTY_VERSION: '0.4.14'
                            }
                        });
                        if (!!skipDownload) return [3, 3];
                        logs_1.l("About to create binaries");
                        return [4, binariesDownload.save()];
                    case 1:
                        _b.sent();
                        logs_1.l("Created and saved binaries");
                        logs_1.l("About to run binaries");
                        return [4, binariesDownload.run()];
                    case 2:
                        _b.sent();
                        logs_1.l("Ran binaries");
                        _b.label = 3;
                    case 3:
                        logs_1.l("About to create configtxyaml");
                        return [4, config.save()];
                    case 4:
                        _b.sent();
                        logs_1.l("Created and saved configtxyaml");
                        logs_1.l("About to create cryptoconfigyaml");
                        return [4, cryptoConfig.save()];
                    case 5:
                        _b.sent();
                        logs_1.l("Created and saved cryptoconfigyaml");
                        logs_1.l("About to create cryptoconfigsh");
                        return [4, cryptoGenerator.save()];
                    case 6:
                        _b.sent();
                        logs_1.l("Created and saved cryptoconfigsh");
                        logs_1.l("Running cryptoconfigsh");
                        return [4, cryptoGenerator.run()];
                    case 7:
                        _b.sent();
                        logs_1.l("Ran cryptoconfigsh");
                        logs_1.l("Building compose");
                        return [4, dockerComposer.build()];
                    case 8:
                        _b.sent();
                        logs_1.l("Builded compose");
                        logs_1.l("Saving compose");
                        return [4, dockerComposer.save()];
                    case 9:
                        _b.sent();
                        logs_1.l("Saved compose");
                        logs_1.l("Creating network profiles");
                        return [4, Promise.all(orgs.map(function (org) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            logs_1.l("Cleaning .hfc-" + org);
                                            return [4, sysWrapper_1.SysWrapper.removePath(path_1.join(path, ".hfc-" + org))];
                                        case 1:
                                            _a.sent();
                                            logs_1.l("Creating for " + org);
                                            return [4, (new networkprofile_yaml_1.NetworkProfileYamlGenerator(org + ".network-profile.yaml", path_1.join(path, './network-profiles'), {
                                                    org: org,
                                                    orgs: orgs,
                                                    networkRootPath: path,
                                                    channels: chs,
                                                    insideDocker: false
                                                })).save()];
                                        case 2:
                                            _a.sent();
                                            logs_1.l("Creating for " + org + " inside Docker");
                                            return [4, (new networkprofile_yaml_1.NetworkProfileYamlGenerator(org + ".network-profile.inside-docker.yaml", path_1.join(path, './network-profiles'), {
                                                    org: org,
                                                    orgs: orgs,
                                                    networkRootPath: path,
                                                    channels: chs,
                                                    insideDocker: true
                                                })).save()];
                                        case 3:
                                            _a.sent();
                                            return [2];
                                    }
                                });
                            }); }))];
                    case 10:
                        _b.sent();
                        logs_1.l("Created network profiles");
                        logs_1.l("Creating network restart script");
                        return [4, networkRestart.save()];
                    case 11:
                        _b.sent();
                        logs_1.l("Saved network restart script");
                        logs_1.l("Running network restart script");
                        return [4, networkRestart.run()];
                    case 12:
                        _b.sent();
                        logs_1.l("Ran network restart script");
                        this.analytics.trackNetworkNew(JSON.stringify({ organizations: organizations, users: users, channels: channels, path: path }));
                        logs_1.l('************ Success!');
                        logs_1.l("Complete network deployed at " + path);
                        logs_1.l("Setup:\n        - Organizations: " + organizations + orgs.map(function (org) { return "\n            * " + org; }).join('') + "\n        - Users per organization: " + usrs + " \n            * admin " + usrs.map(function (usr) { return "\n            * " + usr; }).join('') + "\n        - Channels deployed: " + channels + chs.map(function (ch) { return "\n            * " + ch; }).join('') + "\n        ");
                        logs_1.l("You can find the network topology (ports, names) here: " + path_1.join(path, 'docker-compose.yaml'));
                        return [4, storage_1.SaveNetworkConfig(path, {
                                organizations: organizations, users: users, channels: channels, path: path,
                                hyperledgerVersion: '1.4.0',
                                externalHyperledgerVersion: '0.4.14'
                            })];
                    case 13:
                        _b.sent();
                        return [2];
                }
            });
        });
    };
    NetworkCLI.prototype.clean = function (rmi) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var options, networkClean;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = new networkClean_sh_1.NetworkCleanShOptions();
                        options.removeImages = rmi;
                        networkClean = new networkClean_sh_1.NetworkCleanShGenerator('clean.sh', 'na', options);
                        return [4, networkClean.run()];
                    case 1:
                        _a.sent();
                        this.analytics.trackNetworkClean();
                        logs_1.l('************ Success!');
                        logs_1.l('Environment cleaned!');
                        return [2];
                }
            });
        });
    };
    return NetworkCLI;
}());
exports.NetworkCLI = NetworkCLI;
var buildNetworkConfig = function (params) {
    var orgs = [];
    for (var i = 0; i < params.organizations; i++) {
        orgs.push("org" + (i + 1));
    }
    var chs = [];
    for (var i = 0; i < params.channels; i++) {
        chs.push("ch" + (i + 1));
    }
    var usrs = [];
    params.users = params.users++;
    for (var i = 0; i < params.users; i++) {
        usrs.push("user" + (i + 1));
    }
    return { orgs: orgs, chs: chs, usrs: usrs };
};
var ChaincodeCLI = (function () {
    function ChaincodeCLI(name) {
        this.name = name;
        this.networkRootPath = './hyperledger-fabric-network';
        this.analytics = new analytics_1.Analytics();
    }
    ChaincodeCLI.prototype.installChaincode = function (chaincode, language, channel, version, params, path, ccPath, colConfig, insideDocker, debug) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var homedir, existConfig, config, orgs, chaincodeGenerator;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        homedir = require('os').homedir();
                        path = path ? path_1.resolve(homedir, path) : path_1.join(homedir, this.networkRootPath);
                        return [4, storage_1.ExistNetworkConfig(path)];
                    case 1:
                        existConfig = _a.sent();
                        if (!existConfig) {
                            logs_1.l('Network configuration does not exist. Be sure to first create a new network with `hurley new`');
                            return [2];
                        }
                        return [4, storage_1.LoadNetworkConfig(path)];
                    case 2:
                        config = _a.sent();
                        orgs = buildNetworkConfig(config).orgs;
                        chaincodeGenerator = new chaincodegenerator_1.ChaincodeGenerator(chaincode, {
                            path: ccPath,
                            channel: channel,
                            language: language,
                            version: version,
                            networkRootPath: path,
                            organizations: orgs,
                            params: params,
                            hyperledgerVersion: config.hyperledgerVersion,
                            colConfig: colConfig,
                            insideDocker: insideDocker,
                            debug: debug
                        });
                        return [4, chaincodeGenerator.save()];
                    case 3:
                        _a.sent();
                        return [4, chaincodeGenerator.install()];
                    case 4:
                        _a.sent();
                        this.analytics.trackChaincodeInstall("CHAINCODE=" + chaincode);
                        return [2];
                }
            });
        });
    };
    ChaincodeCLI.prototype.upgradeChaincode = function (chaincode, language, channel, version, params, path, ccPath, colConfig, insideDocker) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var homedir, existConfig, config, orgs, chaincodeGenerator;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        homedir = require('os').homedir();
                        path = path ? path_1.resolve(homedir, path) : path_1.join(homedir, this.networkRootPath);
                        return [4, storage_1.ExistNetworkConfig(path)];
                    case 1:
                        existConfig = _a.sent();
                        if (!existConfig) {
                            logs_1.l('Network configuration does not exist. Be sure to first create a new network with `hurley new`');
                            return [2];
                        }
                        return [4, storage_1.LoadNetworkConfig(path)];
                    case 2:
                        config = _a.sent();
                        orgs = buildNetworkConfig(config).orgs;
                        chaincodeGenerator = new chaincodegenerator_1.ChaincodeGenerator(chaincode, {
                            path: ccPath,
                            channel: channel,
                            language: language,
                            version: version,
                            colConfig: colConfig,
                            networkRootPath: path,
                            organizations: orgs,
                            params: params,
                            hyperledgerVersion: config.hyperledgerVersion,
                            insideDocker: insideDocker
                        });
                        return [4, chaincodeGenerator.save()];
                    case 3:
                        _a.sent();
                        return [4, chaincodeGenerator.upgrade()];
                    case 4:
                        _a.sent();
                        this.analytics.trackChaincodeUpgrade("CHAINCODE=" + chaincode);
                        return [2];
                }
            });
        });
    };
    ChaincodeCLI.prototype.invokeChaincode = function (chaincode, fn, channel, path, user, organization, insideDocker, transientData) {
        var args = [];
        for (var _i = 8; _i < arguments.length; _i++) {
            args[_i - 8] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var homedir, existConfig, config, chaincodeInteractor;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        homedir = require('os').homedir();
                        path = path ? path_1.resolve(homedir, path) : path_1.join(homedir, this.networkRootPath);
                        return [4, storage_1.ExistNetworkConfig(path)];
                    case 1:
                        existConfig = _a.sent();
                        if (!existConfig) {
                            logs_1.l('Network configuration does not exist. Be sure to first create a new network with `hurley new`');
                            return [2];
                        }
                        return [4, storage_1.LoadNetworkConfig(path)];
                    case 2:
                        config = _a.sent();
                        chaincodeInteractor = new (chaincodeinteractor_1.ChaincodeInteractor.bind.apply(chaincodeinteractor_1.ChaincodeInteractor, [void 0, chaincode, fn, {
                                channel: channel,
                                networkRootPath: path,
                                transientData: transientData,
                                hyperledgerVersion: config.hyperledgerVersion,
                                insideDocker: insideDocker,
                                user: user, organization: organization
                            }].concat(args)))();
                        return [4, chaincodeInteractor.invoke()];
                    case 3:
                        _a.sent();
                        this.analytics.trackChaincodeInvoke("CHAINCODE=" + this.installChaincode + " params=" + args);
                        return [2];
                }
            });
        });
    };
    return ChaincodeCLI;
}());
exports.ChaincodeCLI = ChaincodeCLI;
//# sourceMappingURL=cli.js.map