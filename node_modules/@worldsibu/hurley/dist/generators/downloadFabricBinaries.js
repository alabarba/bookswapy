"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var base_1 = require("./base");
var path_1 = require("path");
var DownloadFabricBinariesOptions = (function () {
    function DownloadFabricBinariesOptions() {
    }
    return DownloadFabricBinariesOptions;
}());
exports.DownloadFabricBinariesOptions = DownloadFabricBinariesOptions;
var DownloadFabricBinariesGenerator = (function (_super) {
    tslib_1.__extends(DownloadFabricBinariesGenerator, _super);
    function DownloadFabricBinariesGenerator(filename, path, options) {
        var _this = _super.call(this, filename, path) || this;
        _this.options = options;
        _this.success = path_1.join(_this.path, 'binariesdownload.sh.successful');
        _this.contents = "\n  #!/bin/bash\n  set -e\n# Download the necessary bin files\n\n# if version not passed in, default to latest released version\nexport VERSION=" + _this.options.envVars.FABRIC_VERSION + "\n# if ca version not passed in, default to latest released version\nexport CA_VERSION=$VERSION\n# current version of thirdparty images (couchdb, kafka and zookeeper) released\nexport THIRDPARTY_IMAGE_VERSION=" + _this.options.envVars.THIRDPARTY_VERSION + "\nexport ARCH=$(echo \"$(uname -s|tr '[:upper:]' '[:lower:]'|sed 's/mingw64_nt.*/windows/')-$(uname -m | sed 's/x86_64/amd64/g')\")\nexport MARCH=$(uname -m)\n\n# Incrementally downloads the .tar.gz file locally first, only decompressing it\n# after the download is complete. This is slower than binaryDownload() but\n# allows the download to be resumed.\nbinaryIncrementalDownload() {\n      local BINARY_FILE=$1\n      local URL=$2\n      curl -f -s -C - $URL -o $BINARY_FILE || rc=$?\n      # Due to limitations in the current Nexus repo:\n      # curl returns 33 when there's a resume attempt with no more bytes to download\n      # curl returns 2 after finishing a resumed download\n      # with -f curl returns 22 on a 404\n      if [ \"$rc\" = 22 ]; then\n\t  # looks like the requested file doesn't actually exist so stop here\n\t  return 22\n      fi\n      if [ -z \"$rc\" ] || [ $rc -eq 33 ] || [ $rc -eq 2 ]; then\n          # The checksum validates that RC 33 or 2 are not real failures\n          echo \"==> File downloaded. Verifying the md5sum...\"\n          localMd5sum=$(md5sum $BINARY_FILE | awk '{print $1}')\n          remoteMd5sum=$(curl -s $URL.md5)\n          if [ \"$localMd5sum\" == \"$remoteMd5sum\" ]; then\n              echo \"==> Extracting $BINARY_FILE...\"\n              tar xzf ./$BINARY_FILE --overwrite\n\t      echo \"==> Done.\"\n              rm -f $BINARY_FILE $BINARY_FILE.md5\n          else\n              echo \"Download failed: the local md5sum is different from the remote md5sum. Please try again.\"\n              rm -f $BINARY_FILE $BINARY_FILE.md5\n              exit 1\n          fi\n      else\n          echo \"Failure downloading binaries (curl RC=$rc). Please try again and the download will resume from where it stopped.\"\n          exit 1\n      fi\n}\n\n# This will attempt to download the .tar.gz all at once, but will trigger the\n# binaryIncrementalDownload() function upon a failure, allowing for resume\n# if there are network failures.\nbinaryDownload() {\n      local BINARY_FILE=$1\n      local URL=$2\n      echo \"===> Downloading: \" $URL\n      # Check if a previous failure occurred and the file was partially downloaded\n      if [ -e $BINARY_FILE ]; then\n          echo \"==> Partial binary file found. Resuming download...\"\n          binaryIncrementalDownload $BINARY_FILE $URL\n      else\n          curl $URL | tar xz || rc=$?\n          if [ ! -z \"$rc\" ]; then\n              echo \"==> There was an error downloading the binary file. Switching to incremental download.\"\n              echo \"==> Downloading file...\"\n              binaryIncrementalDownload $BINARY_FILE $URL\n\t  else\n\t      echo \"==> Done.\"\n          fi\n      fi\n}\n\nbinariesInstall() {\n  echo \"===> Downloading version $FABRIC_TAG platform specific fabric binaries\"\n  binaryDownload $BINARY_FILE https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/$ARCH-$VERSION/$BINARY_FILE\n  if [ $? -eq 22 ]; then\n     echo\n     echo \"------> $FABRIC_TAG platform specific fabric binary is not available to download <----\"\n     echo\n   fi\n\n  echo \"===> Downloading version $CA_TAG platform specific fabric-ca-client binary\"\n  binaryDownload $CA_BINARY_FILE https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric-ca/hyperledger-fabric-ca/$ARCH-$CA_VERSION/$CA_BINARY_FILE\n  if [ $? -eq 22 ]; then\n     echo\n     echo \"------> $CA_TAG fabric-ca-client binary is not available to download  (Available from 1.1.0-rc1) <----\"\n     echo\n   fi\n}\n\n\nBINARY_FILE=hyperledger-fabric-$ARCH-$VERSION.tar.gz\nCA_BINARY_FILE=hyperledger-fabric-ca-$ARCH-$CA_VERSION.tar.gz\n\necho \"Installing Hyperledger Fabric binaries\"\n\nDIRECTORY=" + _this.options.networkRootPath + "/fabric-binaries/" + _this.options.envVars.FABRIC_VERSION + "\n\nif [ ! -d \"$DIRECTORY\" ]; then\n    mkdir -p $DIRECTORY\n    cd $DIRECTORY\n    binariesInstall\nfi\n\nif [ -d \"$DIRECTORY\" ]; then\n  echo \"Binaries exist already\"\nfi\n\necho \"Checking IMAGES\"\n\ndockerFabricPull() {\n    local FABRIC_TAG=$1\n    for IMAGES in peer orderer tools; do\n        echo \"==> FABRIC IMAGE: $IMAGES\"\n        echo\n        docker pull hyperledger/fabric-$IMAGES:$FABRIC_TAG\n        docker tag hyperledger/fabric-$IMAGES:$FABRIC_TAG hyperledger/fabric-$IMAGES\n    done\n  }\n  \n  dockerThirdPartyImagesPull() {\n    local THIRDPARTY_TAG=$1\n    for IMAGES in couchdb; do\n        echo \"==> THIRDPARTY DOCKER IMAGE: $IMAGES\"\n        echo\n        docker pull hyperledger/fabric-$IMAGES:$THIRDPARTY_TAG\n        docker tag hyperledger/fabric-$IMAGES:$THIRDPARTY_TAG hyperledger/fabric-$IMAGES\n    done\n  }\n  \n  dockerCaPull() {\n        local CA_TAG=$1\n        echo \"==> FABRIC CA IMAGE\"\n        echo\n        docker pull hyperledger/fabric-ca:$CA_TAG\n        docker tag hyperledger/fabric-ca:$CA_TAG hyperledger/fabric-ca\n  }\n\n  dockerInstall() {\n    which docker >& /dev/null\n    \n    echo \"===> Pulling fabric Images\"\n    dockerFabricPull $FABRIC_TAG\n    echo \"===> Pulling fabric ca Image\"\n    dockerCaPull $CA_TAG\n    echo \"===> Pulling thirdparty docker images\"\n    dockerThirdPartyImagesPull $THIRDPARTY_TAG\n    echo\n    echo \"===> List out hyperledger docker images\"\n    docker images | grep hyperledger*\n\n  }\n\n  # prior to 1.1.0 architecture was determined by uname -m\nif [[ $VERSION =~ ^1.[0].* ]]; then\n  export FABRIC_TAG=$MARCH-$VERSION\n  export CA_TAG=$MARCH-$CA_VERSION\n  export THIRDPARTY_TAG=$MARCH-$THIRDPARTY_IMAGE_VERSION\nelse\n  # starting with 1.2.0, multi-arch images will be default\n  export CA_TAG=\"$CA_VERSION\"\n  export FABRIC_TAG=\"$VERSION\"\n  export THIRDPARTY_TAG=\"$THIRDPARTY_IMAGE_VERSION\"\nfi\n\ndockerInstall\n\n  ";
        return _this;
    }
    return DownloadFabricBinariesGenerator;
}(base_1.BaseGenerator));
exports.DownloadFabricBinariesGenerator = DownloadFabricBinariesGenerator;
//# sourceMappingURL=downloadFabricBinaries.js.map