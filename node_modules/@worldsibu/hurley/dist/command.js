#!/usr/bin/env node
"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var program = require("commander");
var cli_1 = require("./cli");
var updateNotifier = require("update-notifier");
var logs_1 = require("./utils/logs");
var pkg = require('../package.json');
function collect(val, memo) {
    memo.push(val);
    return memo;
}
var tasks = {
    createNetwork: function (organizations, users, channels, path, inside, skipDownload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, cli_1.CLI.createNetwork(organizations, users, channels, path, inside, skipDownload)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    },
    cleanNetwork: function (rmi) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, cli_1.CLI.cleanNetwork(rmi)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    },
    installChaincode: function (chaincode, language, channel, version, params, path, ccPath, colConfig, inside, debug) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, cli_1.CLI.installChaincode(chaincode, language, channel, version, params, path, ccPath, colConfig, inside, debug)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    },
    upgradeChaincode: function (chaincode, language, channel, version, params, path, ccPath, colConfig, inside) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, cli_1.CLI.upgradeChaincode(chaincode, language, channel, version, params, path, ccPath, colConfig, inside)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    },
    invokeChaincode: function (chaincode, fn, channel, path, user, organization, inside, transientData) {
        var args = [];
        for (var _i = 8; _i < arguments.length; _i++) {
            args[_i - 8] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, cli_1.CLI.invokeChaincode.apply(cli_1.CLI, [chaincode, fn, channel, path, user, organization,
                            inside, transientData].concat(args))];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    },
};
program
    .command('new')
    .option('-c, --channels <channels>', 'Channels in the network')
    .option('-o, --organizations <organizations>', 'Amount of organizations')
    .option('-u, --users <users>', 'Users per organization')
    .option('-p, --path <path>', 'Path to deploy the network')
    .option('-i, --inside', 'Optimized for running inside the docker compose network')
    .option('--skip-download', 'Skip downloading the Fabric Binaries and Docker images')
    .action(function (cmd) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!cmd) return [3, 2];
                return [4, tasks.createNetwork(!cmd.organizations || (cmd.organizations <= 2) ? 2 : cmd.organizations, !cmd.users || (cmd.users <= 1) ? 1 : cmd.users, !cmd.channels || (cmd.channels <= 1) ? 1 : cmd.channels, cmd.path, !!cmd.inside, !!cmd.skipDownload)];
            case 1:
                _a.sent();
                return [3, 4];
            case 2: return [4, tasks.createNetwork()];
            case 3:
                _a.sent();
                _a.label = 4;
            case 4: return [2];
        }
    });
}); });
program
    .command('clean')
    .option('-R, --no-rmi', 'Do not remove docker images')
    .action(function (cmd) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, tasks.cleanNetwork(cmd.rmi)];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); });
program
    .command('install <name> <language>')
    .option('-C, --channel <channel>', 'Channel name', collect, [])
    .option('-c, --ctor <constructor>', 'Smart contract constructor params')
    .option('-x, --collections-config <collections-config>', 'Collections config file path (private data)')
    .option('-p, --path <path>', 'Path to deploy the network folder')
    .option('-P, --chaincode-path <path>', 'Path to chaincode package. Default to ./<name>')
    .option('-i, --inside', 'Optimized for running inside the docker compose network')
    .option('-D, --debug', 'Run in debug mode, no container (NodeJS chaincodes only)')
    .action(function (name, language, cmd) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                cmd.channel = (!cmd.channel || cmd.channel.length === 0) ? ['ch1'] : cmd.channel;
                return [4, Promise.all(cmd.channel.map(function (channel) {
                        return tasks.installChaincode(name, language, channel, '1.0', cmd.ctor, cmd.path, cmd.chaincodePath, cmd.collectionsConfig, !!cmd.inside, !!cmd.debug);
                    }))];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); });
program
    .command('upgrade <name> <language> <ver>')
    .option('-C, --channel <channel>', 'Channel name', collect, [])
    .option('-c, --ctor <constructor>', 'Smart contract constructor params')
    .option('-x, --collections-config <collections-config>', 'Collections config file path (private data)')
    .option('-p, --path <path>', 'Path to deploy the network folder')
    .option('-P, --chaincode-path <path>', 'Path to chaincode package. Default to ./<name>')
    .option('-i, --inside', 'Optimized for running inside the docker compose network')
    .action(function (name, language, ver, cmd) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                cmd.channel = (!cmd.channel || cmd.channel.length === 0) ? ['ch1'] : cmd.channel;
                return [4, Promise.all(cmd.channel.map(function (channel) {
                        return tasks.upgradeChaincode(name, language, channel, ver, cmd.ctor, cmd.path, cmd.chaincodePath, cmd.collectionsConfig || '', !!cmd.inside);
                    }))];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); });
program
    .command('invoke <chaincode> <fn> [args...]')
    .option('-C, --channel <channel>', 'Channel name')
    .option('-p, --path <path>', 'Path to deploy the network folder')
    .option('-t, --transient-data <transient-data>', 'Private data, must be BASE64')
    .option('-u, --user <user>', 'Select an specific user to execute command. Default \'user1\'')
    .option('-o, --organization <organization>', 'Select an specific organization to execute command. Default \'org1\'')
    .option('-i, --inside', 'Optimized for running inside the docker compose network')
    .action(function (chaincode, fn, args, cmd) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                args.forEach(function (arg) { return logs_1.l(arg); });
                return [4, tasks.invokeChaincode.apply(tasks, [chaincode,
                        fn,
                        cmd.channel,
                        cmd.path,
                        cmd.user || 'user1',
                        cmd.organization || 'org1',
                        !!cmd.inside,
                        cmd.transientData || ''].concat(args))];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); });
updateNotifier({
    pkg: pkg,
    updateCheckInterval: 1000 * 60
}).notify();
program
    .version(pkg.version);
program.parse(process.argv);
//# sourceMappingURL=command.js.map