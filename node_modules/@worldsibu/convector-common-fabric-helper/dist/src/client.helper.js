"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var js_yaml_1 = require("js-yaml");
var path_1 = require("path");
var Client = require("fabric-client");
var fs_extra_1 = require("fs-extra");
var ClientHelper = (function () {
    function ClientHelper(config) {
        this.config = tslib_1.__assign({ txTimeout: 300000, skipInit: false }, config);
        if (!this.config.skipInit) {
            this.$initializing = this.init();
        }
    }
    Object.defineProperty(ClientHelper.prototype, "organizations", {
        get: function () {
            if (this._organizations) {
                return this._organizations;
            }
            return this.channel ?
                this.channel.getOrganizations()
                    .map(function (org) { return org.id; }) :
                this.networkConfig.getOrganizations()
                    .map(function (org) { return org.getMspid(); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientHelper.prototype, "channels", {
        get: function () {
            var _this = this;
            if (this._channels) {
                return this._channels;
            }
            var channels = Object.keys(this.networkConfig._network_config.channels);
            this._channels = channels.map(function (name) {
                var ch = _this.client.getChannel(name);
                ch.name = ch._name;
                return ch;
            });
            return this._channels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientHelper.prototype, "networkConfig", {
        get: function () {
            return this.client._network_config;
        },
        enumerable: true,
        configurable: true
    });
    ClientHelper.prototype.init = function (initKeyStore) {
        if (initKeyStore === void 0) { initKeyStore = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var stateStore, cryptoSuite, cryptoStore, mspPath, e_1, _a, _b, _c, _d, profileStr, e_2, organizations;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!this.$initializing) return [3, 2];
                        return [4, this.$initializing];
                    case 1: return [2, _e.sent()];
                    case 2:
                        this.client = new Client();
                        if (!initKeyStore) return [3, 11];
                        return [4, Client.newDefaultKeyValueStore({ path: this.config.keyStore })];
                    case 3:
                        stateStore = _e.sent();
                        this.client.setStateStore(stateStore);
                        cryptoSuite = Client.newCryptoSuite();
                        cryptoStore = Client.newCryptoKeyStore({ path: this.config.keyStore });
                        cryptoSuite.setCryptoKeyStore(cryptoStore);
                        this.client.setCryptoSuite(cryptoSuite);
                        mspPath = path_1.resolve(process.cwd(), this.config.userMspPath);
                        _e.label = 4;
                    case 4:
                        _e.trys.push([4, 6, , 7]);
                        return [4, fs_extra_1.ensureDir(mspPath)];
                    case 5:
                        _e.sent();
                        return [3, 7];
                    case 6:
                        e_1 = _e.sent();
                        throw new Error("The userMspPath " + mspPath + " is not reachable or not a directory");
                    case 7:
                        _b = (_a = this.client).createUser;
                        _c = {
                            skipPersistence: false,
                            mspid: this.config.userMsp,
                            username: this.config.user
                        };
                        _d = {};
                        return [4, this.readSingleFileInDir(path_1.join(mspPath, 'keystore'))];
                    case 8:
                        _d.privateKeyPEM = _e.sent();
                        return [4, this.readSingleFileInDir(path_1.join(mspPath, 'signcerts'))];
                    case 9: return [4, _b.apply(_a, [(_c.cryptoContent = (_d.signedCertPEM = _e.sent(),
                                _d),
                                _c)])];
                    case 10:
                        _e.sent();
                        _e.label = 11;
                    case 11:
                        if (!(typeof this.config.networkProfile === 'string')) return [3, 15];
                        _e.label = 12;
                    case 12:
                        _e.trys.push([12, 14, , 15]);
                        return [4, fs_extra_1.readFile(path_1.resolve(process.cwd(), this.config.networkProfile), 'utf8')];
                    case 13:
                        profileStr = _e.sent();
                        if (/\.json$/.test(this.config.networkProfile)) {
                            this.config.networkProfile = JSON.parse(profileStr);
                        }
                        else {
                            this.config.networkProfile = js_yaml_1.safeLoad(profileStr);
                        }
                        return [3, 15];
                    case 14:
                        e_2 = _e.sent();
                        throw new Error("Failed to read or parse the network profile at '" + this.config.networkProfile + "', " + e_2.toString());
                    case 15:
                        organizations = this.config.networkProfile.organizations;
                        return [4, Promise
                                .all(Object.keys(organizations)
                                .map(function (name) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                var org, _a, _b;
                                return tslib_1.__generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            org = organizations[name];
                                            if (!(org.adminPrivateKey && org.signedCert)) return [3, 3];
                                            _a = org.adminPrivateKey;
                                            return [4, this.getLonelyFile(org.adminPrivateKey.path)];
                                        case 1:
                                            _a.path = _c.sent();
                                            _b = org.signedCert;
                                            return [4, this.getLonelyFile(org.signedCert.path)];
                                        case 2:
                                            _b.path = _c.sent();
                                            _c.label = 3;
                                        case 3: return [2];
                                    }
                                });
                            }); }))];
                    case 16:
                        _e.sent();
                        this.client.loadFromConfig(this.config.networkProfile);
                        return [4, this.client.initCredentialStores()];
                    case 17:
                        _e.sent();
                        if (!this.config.user) return [3, 19];
                        return [4, this.useUser(this.config.user)];
                    case 18:
                        _e.sent();
                        _e.label = 19;
                    case 19:
                        if (!this.config.channel) return [3, 21];
                        return [4, this.useChannel(this.config.channel)];
                    case 20:
                        _e.sent();
                        _e.label = 21;
                    case 21: return [2];
                }
            });
        });
    };
    ClientHelper.prototype.useUser = function (name) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4, this.client.getUserContext(name, true)];
                    case 1:
                        _a.user = _b.sent();
                        return [4, this.client.setUserContext(this.user)];
                    case 2:
                        _b.sent();
                        return [2];
                }
            });
        });
    };
    ClientHelper.prototype.useChannel = function (name) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.channel = this.channels.find(function (ch) { return ch.name === name; });
                        return [4, this.channel.initialize()];
                    case 1:
                        _a.sent();
                        return [2, this.channel];
                }
            });
        });
    };
    ClientHelper.prototype.invoke = function (fcn, chaincodeId, config) {
        if (config === void 0) { config = {}; }
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, useAdmin, extra, proposalResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        user = config.user || this.config.user;
                        useAdmin = user === true;
                        if (!!useAdmin) return [3, 2];
                        return [4, this.useUser(user)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        extra = {};
                        if (config.transient) {
                            extra.transientMap = Object.keys(config.transient).reduce(function (map, k) {
                                return (tslib_1.__assign({}, map, (_a = {}, _a[k] = Buffer.from(typeof config.transient[k] === 'string' ?
                                    config.transient[k] : JSON.stringify(config.transient[k])), _a)));
                                var _a;
                            }, {});
                        }
                        return [4, this.sendTransactionProposal(tslib_1.__assign({ fcn: fcn, chaincodeId: chaincodeId, args: args }, extra), useAdmin)];
                    case 3:
                        proposalResponse = (_a.sent()).proposalResponse;
                        return [4, this.processProposal(proposalResponse)];
                    case 4: return [2, _a.sent()];
                }
            });
        });
    };
    ClientHelper.prototype.query = function (fcn, chaincodeId, config) {
        if (config === void 0) { config = {}; }
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var user, useAdmin, txResult, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        user = config.user || this.config.user;
                        useAdmin = user === true;
                        if (!!useAdmin) return [3, 2];
                        return [4, this.useUser(user)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [4, this.sendQueryTx({ fcn: fcn, chaincodeId: chaincodeId, args: args }, useAdmin)];
                    case 3:
                        txResult = _a.sent();
                        result = JSON.parse(txResult.result.response.payload.toString('utf8'));
                        return [2, tslib_1.__assign({}, txResult, { result: result })];
                }
            });
        });
    };
    ClientHelper.prototype.processProposal = function (proposalResponse) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var txRequest, txListener, txResult, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txRequest = this.channel.sendTransaction(proposalResponse);
                        txListener = this.listenTx(proposalResponse.txId.getTransactionID());
                        return [4, this.processTx(txRequest, txListener)];
                    case 1:
                        txResult = _a.sent();
                        result = proposalResponse.proposalResponses[0].response.payload;
                        try {
                            result = JSON.parse(result);
                        }
                        catch (err) {
                        }
                        return [2, tslib_1.__assign({}, txResult, { result: result })];
                }
            });
        });
    };
    ClientHelper.prototype.listenTx = function (txId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var hub;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hub = this.channel.getChannelEventHubsForOrg()[0];
                        hub.connect();
                        return [4, new Promise(function (res, rej) {
                                var timeout = setTimeout(function () {
                                    hub.disconnect();
                                    var seconds = _this.config.txTimeout / 1000;
                                    rej(new Error("Transaction did not complete within " + seconds + " seconds"));
                                }, _this.config.txTimeout);
                                hub.registerTxEvent(txId, function (tx, code) {
                                    clearTimeout(timeout);
                                    hub.unregisterTxEvent(txId);
                                    hub.disconnect();
                                    if (code !== 'VALID') {
                                        return rej(new Error("Problem with the transaction. Event status " + code));
                                    }
                                    res({ txId: txId, code: code });
                                });
                            })];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    ClientHelper.prototype.sendInstantiateProposal = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var txId, _a, proposalResponses, proposal, err;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txId = this.client.newTransactionID(true);
                        request.args = request.args.map(function (arg) {
                            return typeof arg === 'object' ? JSON.stringify(arg) : arg.toString();
                        });
                        return [4, this.channel.sendInstantiateProposal(tslib_1.__assign({}, request, { txId: txId }), this.config.txTimeout)];
                    case 1:
                        _a = _b.sent(), proposalResponses = _a[0], proposal = _a[1];
                        if (!proposalResponses.every(function (pr) { return pr.response && pr.response.status === 200; })) {
                            err = new Error('Transaction proposal was bad');
                            err['responses'] = proposalResponses;
                            throw err;
                        }
                        return [2, {
                                result: proposalResponses[0],
                                proposalResponse: {
                                    txId: txId,
                                    proposal: proposal,
                                    proposalResponses: proposalResponses
                                }
                            }];
                }
            });
        });
    };
    ClientHelper.prototype.sendUpgradeProposal = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var txId, _a, proposalResponses, proposal, err;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txId = this.client.newTransactionID(true);
                        request.args = request.args.map(function (arg) {
                            return typeof arg === 'object' ? JSON.stringify(arg) : arg.toString();
                        });
                        return [4, this.channel.sendUpgradeProposal(tslib_1.__assign({}, request, { txId: txId }), this.config.txTimeout)];
                    case 1: return [4, _b.sent()];
                    case 2:
                        _a = _b.sent(), proposalResponses = _a[0], proposal = _a[1];
                        if (!proposalResponses.every(function (pr) { return pr.response && pr.response.status === 200; })) {
                            err = new Error('Transaction proposal was bad');
                            err['responses'] = proposalResponses;
                            throw err;
                        }
                        return [2, {
                                result: proposalResponses[0],
                                proposalResponse: {
                                    txId: txId,
                                    proposal: proposal,
                                    proposalResponses: proposalResponses
                                }
                            }];
                }
            });
        });
    };
    ClientHelper.prototype.sendTransactionProposal = function (request, useAdmin) {
        if (useAdmin === void 0) { useAdmin = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var txId, _a, proposalResponses, proposal, err;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txId = this.client.newTransactionID(useAdmin);
                        request.args = (request.args || []).map(function (arg) {
                            if (!arg) {
                                throw new Error('Undefined parameters received as part of the transaction, check how the function is being called');
                            }
                            return typeof arg === 'object' ? JSON.stringify(arg) : arg.toString();
                        });
                        return [4, this.channel.sendTransactionProposal(tslib_1.__assign({}, request, { txId: txId }), this.config.txTimeout)];
                    case 1:
                        _a = _b.sent(), proposalResponses = _a[0], proposal = _a[1];
                        if (!proposalResponses.every(function (pr) { return pr.response && pr.response.status === 200; })) {
                            err = new Error('Transaction proposal was bad');
                            err['responses'] = proposalResponses;
                            throw err;
                        }
                        return [2, {
                                result: proposalResponses[0],
                                proposalResponse: {
                                    txId: txId,
                                    proposal: proposal,
                                    proposalResponses: proposalResponses
                                }
                            }];
                }
            });
        });
    };
    ClientHelper.prototype.sendQueryTx = function (request, useAdmin) {
        if (useAdmin === void 0) { useAdmin = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var txId, queryPeers, _a, proposalResponses, proposal, successResponse, err;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txId = this.client.newTransactionID(useAdmin);
                        request.args = (request.args || []).map(function (arg) {
                            if (!arg) {
                                throw new Error('Undefined parameters received as part of the transaction, check how the function is being called');
                            }
                            return typeof arg === 'object' ? JSON.stringify(arg) : arg.toString();
                        });
                        queryPeers = this.channel.getPeers()
                            .filter(function (peer) { return peer.isInRole('chaincodeQuery'); })
                            .map(function (peer) { return peer.getPeer(); });
                        return [4, this.channel.sendTransactionProposal(tslib_1.__assign({}, request, { txId: txId, targets: queryPeers }), this.config.txTimeout)];
                    case 1:
                        _a = _b.sent(), proposalResponses = _a[0], proposal = _a[1];
                        successResponse = proposalResponses
                            .find(function (pr) { return pr.response && pr.response.status === 200; });
                        if (!successResponse) {
                            err = new Error('All query responses were bad');
                            err['responses'] = proposalResponses;
                            throw err;
                        }
                        return [2, {
                                result: successResponse,
                                proposalResponse: {
                                    txId: txId,
                                    proposal: proposal,
                                    proposalResponses: proposalResponses
                                }
                            }];
                }
            });
        });
    };
    ClientHelper.prototype.processTx = function (txRequest, txListener) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, tx, response, err;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, Promise.all([txRequest, txListener])];
                    case 1:
                        _a = _b.sent(), tx = _a[0], response = _a[1];
                        if (!tx || tx.status !== 'SUCCESS' || !response || response.code !== 'VALID') {
                            err = new Error("Transaction failed. Status " + tx.status + ". Response " + response.code);
                            Object.assign(err, { tx: tx, response: response });
                            throw err;
                        }
                        return [2, tslib_1.__assign({}, tx, response)];
                }
            });
        });
    };
    ClientHelper.prototype.readSingleFileInDir = function (dirPath) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_3, content;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4, fs_extra_1.ensureDir(dirPath)];
                    case 1:
                        _a.sent();
                        return [3, 3];
                    case 2:
                        e_3 = _a.sent();
                        throw new Error("The directory " + dirPath + " is not reachable or not a directory");
                    case 3: return [4, fs_extra_1.readdir(dirPath)];
                    case 4:
                        content = _a.sent();
                        if (content.length !== 1) {
                            throw new Error("The directory " + dirPath + " is supposed to only have one file, but found " + content.length);
                        }
                        return [4, fs_extra_1.readFile(path_1.join(dirPath, content[0]), 'utf8')];
                    case 5: return [2, _a.sent()];
                }
            });
        });
    };
    ClientHelper.prototype.getLonelyFile = function (folderPath) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var isFile, isDir, content;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        folderPath = path_1.resolve(folderPath);
                        return [4, fs_extra_1.ensureFile(folderPath)
                                .then(function () { return Promise.resolve(true); })
                                .catch(function () { return Promise.resolve(false); })];
                    case 1:
                        isFile = _a.sent();
                        return [4, fs_extra_1.ensureDir(folderPath)
                                .then(function () { return Promise.resolve(true); })
                                .catch(function () { return Promise.resolve(false); })];
                    case 2:
                        isDir = _a.sent();
                        if (isFile) {
                            return [2, folderPath];
                        }
                        if (!isDir) {
                            throw new Error("Path '" + folderPath + "' neither a file or a directory");
                        }
                        return [4, fs_extra_1.readdir(folderPath)];
                    case 3:
                        content = _a.sent();
                        if (content.length !== 1) {
                            throw new Error("Directory '" + folderPath + "' must contain only one file, but contains " + content.length);
                        }
                        return [2, path_1.join(folderPath, content[0])];
                }
            });
        });
    };
    return ClientHelper;
}());
exports.ClientHelper = ClientHelper;
//# sourceMappingURL=client.helper.js.map